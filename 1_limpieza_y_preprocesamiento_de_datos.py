# -*- coding: utf-8 -*-
"""1. Limpieza y preprocesamiento de datos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18I078i52M_vi8r2ECE8WtOtzx0Z0DYVH

# <font color='056938'> **Librerias** </font>
"""

from google.colab import drive
import sys
import os
import numpy as np
import pandas as pd
import sqlite3 as sql
import plotly.graph_objs as go ### para gráficos
import plotly.express as px
import matplotlib.pyplot as plt

drive.mount('/content/drive')

#Define la parte del directorio que quieres trabajar
path = "/content/drive/MyDrive/Mod2/ANALITICA3"

sys.path.append(path)##para importar archivo de funciones propias a traves de import
os.chdir(path)## para que por defecto suba y descargue archivos partiendo de esa ruta
sys.path.append(f"{path}") #agragarle al path, poder leer

"""# <font color='056938'> **Cargar base de datos** </font>"""

con=sql.connect("data//db_movies")# conectarse a base de datos existente

cur=con.cursor()#otro tipo de conexión para ejecutar consultas en la base de datos sin traer ni llevar información

cur.execute("""SELECT name FROM sqlite_master WHERE type='table'""")
cur.fetchall()

"""<font color='056938'> **Tabla de movies** </font>"""

df_movies=pd.read_sql("""SELECT * FROM movies""",con)
df_movies

"""<font color='056938'> **Tabla de ratings** </font>"""

df_ratings=pd.read_sql("""SELECT * FROM ratings""",con)
df_ratings

"""<font color='056938'> **1. Verificar datos faltantes** </font>"""

# Muestra las variables que tienen datos faltantes en la base de datos calculo diferencial
df_movies.isnull().any()

# Muestra las variables que tienen datos faltantes en la base de datos calculo diferencial
df_ratings.isnull().any()

"""No se evidencia datos faltantes en ninguna de las dos tablas

<font color='056938'> **2. Verificar datos duplicados** </font>
"""

# Identificar las filas duplicadas incluyendo todas las filas duplicadas
duplicados_movies = df_movies.duplicated(keep=False)

# Filtrar y mostrar las filas duplicadas
filas_duplicadas_movies = df_movies[duplicados_movies]

filas_duplicadas_movies

# Identificar las filas duplicadas incluyendo todas las filas duplicadas
duplicados_ratings = df_ratings.duplicated(keep=False)

# Filtrar y mostrar las filas duplicadas
filas_duplicadas_ratings = df_ratings[duplicados_ratings]

filas_duplicadas_ratings

"""Las dos tablas no tienen datos duplicados

<font color='056938'> **3. Verificar outliers** </font>

Observar distribución de la tabla ratings

**a) Calcular la distribución de calificaciones**
"""

ratings_count = pd.read_sql("""
    SELECT
        "rating" AS Rating,
        COUNT(*) AS conteo
    FROM ratings
    GROUP BY "rating"
    ORDER BY conteo desc
""", con)

data  = go.Bar( x=ratings_count.Rating,y=ratings_count.conteo, text=ratings_count.conteo, textposition="outside")
Layout=go.Layout(title="Count of ratings",xaxis={'title':'Rating'},yaxis={'title':'Count'})
go.Figure(data,Layout)

"""Se observa que todas las películas han recibido calificaciones, sin registrarse valores de cero. Además,la mayoria de las peliculas cuentan con buena calificación

**b) Calcular la cantidad de calificaciones que  hizo cada usuario**
"""

# conteo de calificaciones por cada usuario
user_ratings_count = pd.read_sql("""
    SELECT
        "userId" AS user_id,
        COUNT(*) AS conteo_calificaciones
    FROM ratings
    GROUP BY "userId"
    ORDER BY conteo_calificaciones asc
""", con)

# gráfica
calificaciones_user = go.Bar(x=user_ratings_count.user_id, y=user_ratings_count.conteo_calificaciones,
              text=user_ratings_count.conteo_calificaciones, textposition="outside")
layout = go.Layout(title="Conteo de Calificaciones por Usuario",
                   xaxis={'title': 'User ID'},
                   yaxis={'title': 'Conteo de Calificaciones'})
go.Figure(data=[calificaciones_user ], layout=layout)

# boxplot para visualizar la distribución de las calificaciones por usuario
box_user_rating = go.Box(
    y=user_ratings_count.conteo_calificaciones,  # Datos de las calificaciones
    name="Conteo de Calificaciones por Usuario"
)

layout = go.Layout(
    title="Boxplot: Distribución de las Calificaciones por Usuario",
    yaxis={'title': 'Conteo de Calificaciones'},
)

# Mostrar el gráfico
go.Figure(data=[box_user_rating], layout=layout)

"""En los gráficos se observa la presencia de outliers, donde pocos usuarios registran más de 500 calificaciones. Para reducir el sesgo que esto podría generar, se crea una tabla que incluye únicamente a los usuarios que han calificado más de 50 y menos de 500 películas.

Tabla de usuarios con más de 50 peliculas calificadas y menos de 500
"""

with con:
    con.execute("""
        DROP TABLE IF EXISTS usuarios_sel;
    """)
    con.execute("""
        CREATE TABLE usuarios_sel AS
        SELECT
            "userId" AS user_id,
            COUNT(*) AS conteo_calificaciones
        FROM ratings
        GROUP BY "userId"
        HAVING conteo_calificaciones > 50 AND conteo_calificaciones <= 500
        ORDER BY conteo_calificaciones ASC
    """)

# 2. Leer los datos de la tabla usuarios_sel
user_ratings_count2 = pd.read_sql("SELECT * FROM usuarios_sel", con)

# boxplot para visualizar la distribución de las calificaciones por usuario
box_user_rating2 = go.Box(
    y=user_ratings_count2.conteo_calificaciones,  # Datos de las calificaciones
    name="Conteo de Calificaciones por Usuario"
)

layout = go.Layout(
    title="Boxplot: Distribución de las Calificaciones por Usuario",
    yaxis={'title': 'Conteo de Calificaciones'},
)

# Mostrar el gráfico
go.Figure(data=[box_user_rating2], layout=layout)

"""**c) Calcular cuantas calificaciones tiene cada pelicula**"""

# Consulta para obtener el número de usuarios que han visto cada película
movies_rating = pd.read_sql("""
    SELECT
        "movieId" AS movie_id,
        COUNT(*) AS conteo_peliculas
    FROM ratings
    GROUP BY "movieId"
    ORDER BY conteo_peliculas desc
""", con)

# boxplot para visualizar la distribución de las calificaciones por usuario
box_movie_rat = go.Box(
    y=movies_rating.conteo_peliculas,  # Datos de las calificaciones
    name="Conteo de peliculas vistas"
)

layout = go.Layout(
    title="Boxplot: Distribución de las peliculas calificadas",
    yaxis={'title': 'Conteo de peliculas calificadas'},
)

# Mostrar el gráfico
go.Figure(data=[box_movie_rat], layout=layout)

"""En el boxplot se evidencia la presencia de varios outliers, donde algunas películas tienen un mínimo de una calificación. Dado que para generar recomendaciones precisas se requiere que una pelicula tenga varias recomendaciones de diferentes usuarios, por tanto, se excluyen aquellas películas que no cuenten con más de 50 calificaciones.

Tabla de peliculas con más de 50 peliculas calificaciones
"""

with con:
    con.execute("""
        DROP TABLE IF EXISTS peliculas_sel;
    """)
    con.execute("""
        CREATE TABLE peliculas_sel AS
        SELECT
            "movieId" AS movie_id,
            COUNT(*) AS conteo_peliculas
        FROM ratings
        GROUP BY "movieId"
        HAVING conteo_peliculas >= 50
        ORDER BY conteo_peliculas DESC
    """)

# 2. Leer los datos de la tabla peliculas_sel
movies_rating2 = pd.read_sql("SELECT * FROM peliculas_sel", con)

# 3. Gráfico boxplot para la distribución
box_movie_rat2 = go.Box(
    y=movies_rating2.conteo_peliculas,  # Datos de conteo de películas
    name="Conteo de películas calificadas"
)

layout = go.Layout(
    title="Boxplot: Distribución de las películas calificadas",
    yaxis={'title': 'Conteo de películas calificadas'},
)

# Mostrar el gráfico
fig = go.Figure(data=[box_movie_rat2], layout=layout)
fig.show()

"""**d)Crear tabla completa para utilizar en los modelos**

Crea una nueva tabla llamada ratings_final que contiene: el ID del usuario, el ID de la película, la calificación dada y la fecha/hora de la calificación. Pero solo para los usuarios que están en usuarios_sel y las películas que están en peliculas_sel.
"""

# Tabla 'ratings_final' que combina 'ratings' con 'usuarios_sel' y 'peliculas_sel'
with con:
    con.execute("DROP TABLE IF EXISTS ratings_final")

with con:
    con.execute("""
        CREATE TABLE ratings_final AS
        SELECT a."userId" AS user_id,
               a."movieId" AS movie_id,
               a."rating" AS movie_rating,
               a."timestamp" AS movie_timestamp
        FROM ratings a
        INNER JOIN usuarios_sel b ON a."userId" = b.user_id
        INNER JOIN peliculas_sel c ON a."movieId" = c.movie_id
    """)

# Visualizar la tabla 'ratings_final'
ratings_final = pd.read_sql("SELECT * FROM ratings_final", con)
ratings_final.head()

"""Crea una nueva tabla llamada movies_final que contiene: El ID de la película, el nombre de la película, los géneros de la película, pero solo con las películas que aparecen en peliculas_sel."""

# Crear tabla 'movies_final' basada en 'movies' y 'peliculas_sel'
with con:
    con.execute("DROP TABLE IF EXISTS movies_final")

with con:
    con.execute("""
        CREATE TABLE movies_final AS
        SELECT a."movieId" AS movie_id,
               a."title" AS movie_title,
               a."genres" AS movie_genres
        FROM movies a
        INNER JOIN peliculas_sel b ON a."movieId" = b.movie_id
    """)

# Visualizar la tabla 'movies_final'
movies_final = pd.read_sql("SELECT * FROM movies_final", con)
movies_final.head()

"""Con las tablas previamente limpiadas, se procede a crear una tabla consolidada que incluya el ID del usuario, el ID de la película, el nombre de la película, su género, la calificación y la fecha/hora de la calificación. Esta tabla se genera la información de las calificaciones en la tabla ratings_final y la información de las películas de la tabla movies_final, usando un INNER JOIN para unir las tablas donde coincidan con el ID de la pelicula."""

with con:
    con.execute("""
        DROP TABLE IF EXISTS full_ratings;
    """)
    con.execute("""
        CREATE TABLE full_ratings AS
        SELECT
            a.user_id,
            a.movie_id,
            b.movie_title,
            b.movie_genres,
            a.movie_rating,
            a.movie_timestamp
        FROM ratings_final a
        INNER JOIN movies_final b ON a.movie_id = b.movie_id
    """)

# 2. Leer la tabla full_ratings
tabla_completa = pd.read_sql("SELECT * FROM full_ratings", con)

# 3. Visualizar
tabla_completa

## al cruzar tablas a veces se duplican registros, por tanto se identifican las filas duplicadas incluyendo todas las filas duplicadas
duplicados_completa = tabla_completa.duplicated(keep=False)

# Filtrar y mostrar las filas duplicadas
filas_duplicadas_completa = tabla_completa[duplicados_completa]

filas_duplicadas_completa

"""No hay datos duplicados

Para facilitar la construcción de los modelos de recomendación, se extrae el año de estreno desde el campo movie_title y se crea una nueva columna denominada movie_year.
"""

# Extraer el año desde movie_title y crear la nueva columna movie_year
tabla_completa['movie_year'] = tabla_completa['movie_title'].str.extract(r'\((\d{4})\)', expand=False)

# Convertir a numérico
tabla_completa['movie_year'] = pd.to_numeric(tabla_completa['movie_year'], errors='coerce')

tabla_completa['movie_title'] = tabla_completa['movie_title'].str.replace(r'\s*\(\d{4}\)', '', regex=True)
tabla_completa.head()

# Guardar la columna incluida en la tabla full_rating
tabla_completa.to_sql('full_ratings', con, if_exists='replace', index=False)
tabla_completa

"""Esta tabla de full ratings se utilizará para realizar los modelos"""