# -*- coding: utf-8 -*-
"""5.despliegue

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LTiLp4h8X6Do1_Y1bYbRXKGqayP1nV0a

# <font color='056938'> **Librerias** </font>
"""

import numpy as np
import pandas as pd
import sqlite3 as sql
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import NearestNeighbors
import logging
from tqdm import tqdm
import os
import sys

"""
# <font color='056938'> **Conexion con Drive** </font>"""

# Conexion con Drive
from google.colab import drive
drive.mount('/content/drive')

# Cambio de directorio de Trabajo

path = '/content/drive/MyDrive/Mod2/ANALITICA3'
os.chdir(path)
sys.path.append(path)

"""# <font color='056938'> **Cargar base de datos** </font>"""

conn=sql.connect('/content/drive/MyDrive/Mod2/ANALITICA3/data/db_movies')
cur=conn.cursor() ###para funciones que ejecutan sql en base de datos

"""# <font color='056938'> **Configuración del log** </font>"""

logging.basicConfig(
    filename='/content/drive/MyDrive/Mod2/ANALITICA3/logs/script_log.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# Cargar la tabla completa
tabla_completa = pd.read_sql_query("SELECT * FROM full_ratings", conn)

# Verificación de la tabla cargada
tabla_completa.info()

# Escalar el año para que esté en el mismo rango
sc = StandardScaler()
tabla_completa[["year_sc"]] = sc.fit_transform(tabla_completa[['movie_year']])

"""
**Separacion de generos**"""

# Separar los géneros y expandirlos en múltiples filas
df_genres = tabla_completa.assign(movie_genres=tabla_completa['movie_genres'].str.split('|')).explode('movie_genres')
df_genres = df_genres.rename(columns={'movie_genres': 'genre'})

# Eliminar las columnas que no se van a usar
movie_dum1 = df_genres.drop(columns=['user_id', 'movie_rating', 'movie_timestamp', 'movie_year', 'movie_title'])

""" **Dumización de géneros**"""

movie_dum1['genre'].nunique()
col_dum = ['genre']
movie_dum2 = pd.get_dummies(movie_dum1, columns=col_dum)

# Unificar las películas por 'movie_id'
movie_unificado = movie_dum2.groupby('movie_id', as_index=False).max()

def Tabla_procesada(conn):
    # Cargar la tabla
    tabla_completa = pd.read_sql_query("SELECT * FROM full_ratings", conn)

    # Escalar el año
    sc = StandardScaler()
    tabla_completa[["year_sc"]] = sc.fit_transform(tabla_completa[['movie_year']])

    # Separar géneros y expandir
    df_genres = tabla_completa.assign(movie_genres=tabla_completa['movie_genres'].str.split('|')).explode('movie_genres')
    df_genres = df_genres.rename(columns={'movie_genres': 'genre'})

    # Eliminar columnas innecesarias
    movie_dum1 = df_genres.drop(columns=['user_id', 'movie_rating', 'movie_timestamp', 'movie_year', 'movie_title'])

    # Dumificación
    movie_dum2 = pd.get_dummies(movie_dum1, columns=['genre'])

    # Unificar por movie_id
    movie_unificado = movie_dum2.groupby('movie_id', as_index=False).max()

    # También devolver tabla original para nombres de películas
    return movie_unificado, tabla_completa

"""# <font color='056938'> **Modelo KNN basado en contenido** </font>"""

model = NearestNeighbors(n_neighbors=10, metric='cosine')
model.fit(movie_unificado)

# Función interactiva para obtener recomendaciones
def MovieRecommender(movie_name=list(tabla_completa['movie_title'].value_counts().index)):
    movie_list_name = []
    movie_id = tabla_completa[tabla_completa['movie_title'] == movie_name].index
    movie_id = movie_id[0]

    for newid in idlist[movie_id]:
        movie_list_name.append(tabla_completa.loc[newid].movie_title)

    return movie_list_name

import sys
sys.path.append('/content/drive/MyDrive/Mod2/ANALITICA3/Trabajo Marketing')

from preprocesamiento import Tabla_procesada

def preprocesar(conn=None, cur=None):
    movie_dum2, movie = Tabla_procesada(conn)
    return movie_dum2, movie, conn, cur

# Función de recomendación para usuarios
def recomendar(user_id, conn=None, cur=None, movie_dum2=None, movie=None):
    ratings = pd.read_sql('SELECT * FROM ratings_final WHERE user_id=:user', conn, params={'user': user_id})
    l_movies_r = ratings['movie_id'].to_numpy()
    movie_dum2[['movie_id', 'movie_title']] = movie[['movie_id', 'movie_title']]
    movies_r = movie_dum2[movie_dum2['movie_id'].isin(l_movies_r)]
    movies_r = movies_r.drop(columns=['movie_id', 'movie_title'])
    movies_r["indice"] = 1  # Para usar group by y quedar con formato de tabla de centroide
    centroide = movies_r.groupby("indice").mean()

    # Filtrar películas no vistas por el usuario
    movies_nr = movie_dum2[~movie_dum2['movie_id'].isin(l_movies_r)]
    movies_nr = movies_nr.drop(columns=['movie_id', 'movie_title'])

    # Aplicar el modelo KNN
    model = NearestNeighbors(n_neighbors=11, metric='cosine')
    model.fit(movies_nr)
    dist, idlist = model.kneighbors(centroide)

    ids = idlist[0]
    recomend_b = movie.loc[ids][['movie_title', 'movie_id']]

    return recomend_b

# Función para procesar y guardar recomendaciones
def main(list_user):
    conn = sql.connect('/content/drive/MyDrive/Mod2/ANALITICA3/data/db_movies')
    cur = conn.cursor()

    recomendaciones_todos = pd.DataFrame()
    movie_dum2, movie, conn, cur = preprocesar(conn, cur)

    for user_id in tqdm(list_user):
        recomendaciones = recomendar(user_id, conn, cur, movie_dum2, movie)
        recomendaciones["user_id"] = user_id
        recomendaciones.reset_index(inplace=True, drop=True)

        recomendaciones_todos = pd.concat([recomendaciones_todos, recomendaciones])

    # Guardar las recomendaciones generadas
    recomendaciones_todos.to_excel('/content/drive/MyDrive/Mod2/ANALITICA3/salidas/recomendaciones.xlsx')
    recomendaciones_todos.to_csv('/content/drive/MyDrive/Mod2/ANALITICA3/salidas/recomendaciones.csv')

# Ejecutar el código principal
if __name__ == "__main__":
    list_user = [52853, 31226, 167471, 8066]
    main(list_user)