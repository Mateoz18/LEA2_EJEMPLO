# -*- coding: utf-8 -*-
"""3.Modelo_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IqsH9HsFn5McJ2q7x-Pg1eZ4_Mq7EG0r
"""

import numpy as np
import pandas as pd
import sqlite3 as sql
import plotly.graph_objs as go ### para gráficos
import plotly.express as px
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import LabelEncoder
from ipywidgets import interact ## para análisis interactivo
from sklearn import neighbors ### basado en contenido un solo producto consumido
import joblib
from sklearn.neighbors import NearestNeighbors

# Conexion con Drive
from google.colab import drive
drive.mount('/content/drive')

# Cambio de directorio de Trabajo
import os
import sys
path = '/content/drive/MyDrive/Mod2/ANALITICA3'
os.chdir(path)
sys.path.append(path)

import sqlite3 as sql
import pandas as pd
import numpy as np

conn=sql.connect('/content/drive/MyDrive/Mod2/ANALITICA3/data/db_movies')
cur=conn.cursor() ###para funciones que ejecutan sql en base de datos

### para verificar las tablas que hay disponibles
cur.execute("SELECT name FROM sqlite_master where type='table' ")
cur.fetchall()

# Cargas la tabla que ya contiene los datos procesados
tabla_completa = pd.read_sql_query("SELECT * FROM full_ratings", conn)

tabla_completa

tabla_completa.info()#Se confirma que año sea de tipo entero

#se escala el año para que este en el mismo rango
sc = StandardScaler()
tabla_completa[["year_sc"]]=sc.fit_transform(tabla_completa[['movie_year']])

"""Este codigo de abajo es provisional mientras averiguo como traer la que monte en el sql :)"""

# Separar los géneros por el carácter '|' y expandirlos en múltiples filas, se hace de esta manera ya que sqlite no tiene esa funcion SALE EN FILAS
df_genres = tabla_completa.assign(movie_genres=tabla_completa['movie_genres'].str.split('|')).explode('movie_genres')

# Renombrar para claridad
df_genres = df_genres.rename(columns={'movie_genres': 'genre'})

df_genres

#sacar las filas que no se van a utilizar
movie_dum1 = df_genres.drop(columns = ['user_id', 'movie_rating', 'movie_timestamp', 'movie_year', 'movie_title'])
movie_dum1

movie_dum1['genre'].nunique()# se verifica cuantos generos únicos hay

#se dumiza los generos
col_dum = ['genre']
movie_dum2 = pd.get_dummies(movie_dum1, columns = col_dum)
movie_dum2

#Al quedar varios registros por filas de la misma pelicula pero todas con genero diferente se agrupan para disminuir la cantidad de datos a procesar a solamente un registro de pelicula
movie_unificado = movie_dum2.groupby('movie_id', as_index=False).max()
movie_unificado

#se define el modelo knn con 10 recomendaciones, se usa la métrica coseno
model = neighbors.NearestNeighbors(n_neighbors=10, metric='cosine')

#se entrena el modelo
model.fit(movie_unificado)

#se definen los arrays de distancia(en terminos del coseno) y los ids para saber que pelicula es
dist, idlist = model.kneighbors(movie_unificado)

#distancias mas cercanas, entre mas cercano a cero mas se parecen las peliculas, esas son las que se van a recomendar
distancias = pd.DataFrame(dist)
distancias

#Para saber a que id de pelicula es
id_list = pd.DataFrame(idlist)#
id_list

#función interactiva para consultar las recomendaciones
def MovieRecommender(movie_name = list(tabla_completa['movie_title'].value_counts().index)):
    movie_list_name = []
    movie_id = tabla_completa[tabla_completa['movie_title'] == movie_name].index
    movie_id = movie_id[0]
    for newid in idlist[movie_id]:
        movie_list_name.append(tabla_completa.loc[newid].movie_title)
    return movie_list_name

print(interact(MovieRecommender))